# Consolidated Typescript Docs

## Contents

*   [JS-UI libs/typescript/alinks.md](#js-ui-libstypescriptalinksmd)
*   [JS-UI libs/typescript/ts-event.md](#js-ui-libstypescriptts-eventmd)
*   [JS-UI libs/typescript/unknown-never.md](#js-ui-libstypescriptunknown-nevermd)
*   [JS-UI libs/typescript/10.dom-types/element.md](#js-ui-libstypescript10dom-typeselementmd)
*   [JS-UI libs/typescript/2-basic types/arrays.md](#js-ui-libstypescript2-basic-typesarraysmd)
*   [JS-UI libs/typescript/2-other-types.md/a1-5-union-intersections.md](#js-ui-libstypescript2-other-typesmda1-5-union-intersectionsmd)
*   [JS-UI libs/typescript/2-other-types.md/a1-6-TypeAlias-interface.md](#js-ui-libstypescript2-other-typesmda1-6-typealias-interfacemd)
*   [JS-UI libs/typescript/2-other-types.md/a1-8-literal-types-inference.md](#js-ui-libstypescript2-other-typesmda1-8-literal-types-inferencemd)
*   [JS-UI libs/typescript/2-other-types.md/a1-9-enums.md](#js-ui-libstypescript2-other-typesmda1-9-enumsmd)
*   [JS-UI libs/typescript/2-other-types.md/object-unknown-never.md](#js-ui-libstypescript2-other-typesmdobject-unknown-nevermd)
*   [JS-UI libs/typescript/3-narrowing/1.narrowing.md](#js-ui-libstypescript3-narrowing1narrowingmd)
*   [JS-UI libs/typescript/3-narrowing/1.typeof type guard.md](#js-ui-libstypescript3-narrowing1typeoftypeguardmd)
*   [JS-UI libs/typescript/3-narrowing/2.typeguards.md](#js-ui-libstypescript3-narrowing2typeguardsmd)
*   [JS-UI libs/typescript/3-narrowing/3.type-guards.md](#js-ui-libstypescript3-narrowing3type-guardsmd)
*   [JS-UI libs/typescript/3-narrowing/4.intersect-strategy.md](#js-ui-libstypescript3-narrowing4intersect-strategymd)
*   [JS-UI libs/typescript/3-narrowing/4.intersection.md](#js-ui-libstypescript3-narrowing4intersectionmd)
*   [JS-UI libs/typescript/3-narrowing/6-assignments.md](#js-ui-libstypescript3-narrowing6-assignmentsmd)
*   [JS-UI libs/typescript/3-narrowing/7-discriminated-unions.md](#js-ui-libstypescript3-narrowing7-discriminated-unionsmd)
*   [JS-UI libs/typescript/7-classes/11.classes.md](#js-ui-libstypescript7-classes11classesmd)
*   [JS-UI libs/typescript/7-generics/0.generics.md](#js-ui-libstypescript7-generics0genericsmd)
*   [JS-UI libs/typescript/7-generics/1.ang-brackets.md](#js-ui-libstypescript7-generics1ang-bracketsmd)
*   [JS-UI libs/typescript/7-generics/1.generics what.md](#js-ui-libstypescript7-generics1genericswhatmd)
*   [JS-UI libs/typescript/7-generics/1.generics-builtIn.md](#js-ui-libstypescript7-generics1generics-builtinmd)
*   [JS-UI libs/typescript/7-generics/2.generic-func.md](#js-ui-libstypescript7-generics2generic-funcmd)
*   [JS-UI libs/typescript/7-generics/2.generic-funcs.md](#js-ui-libstypescript7-generics2generic-funcsjmd)
*   [JS-UI libs/typescript/7-generics/3.generic-obj.md](#js-ui-libstypescript7-generics3generic-objmd)
*   [JS-UI libs/typescript/7-generics/generics3.md](#js-ui-libstypescript7-genericsgenerics3md)
*   [JS-UI libs/typescript/7-generics/genertics2.md](#js-ui-libstypescript7-genericsgenertics2md)
*   [JS-UI libs/typescript/9-reference/compatibility.md](#js-ui-libstypescript9-referencecompatibilitymd)
*   [JS-UI libs/typescript/9-reference/partials.md](#js-ui-libstypescript9-referencepartialsmd)
*   [JS-UI libs/typescript/typescript-react/0.getting-started.md](#js-ui-libstypescripttypescript-react0getting-startedmd)
*   [JS-UI libs/typescript/typescript-react/1.props-state.md](#js-ui-libstypescripttypescript-react1props-statemd)
*   [JS-UI libs/typescript/typescript-react/2.state.md](#js-ui-libstypescripttypescript-react2statemd)
*   [JS-UI libs/typescript/2-basic types/2-functions/0.syntax.md](#js-ui-libstypescript2-basic-types2-functions0syntaxmd)
*   [JS-UI libs/typescript/2-basic types/2-functions/1.parameters.md](#js-ui-libstypescript2-basic-types2-functions1parametersmd)
*   [JS-UI libs/typescript/2-basic types/2-functions/2. signatures.md](#js-ui-libstypescript2-basic-types2-functions2signaturesmd)
*   [JS-UI libs/typescript/2-basic types/2-functions/3.signatures2.md](#js-ui-libstypescript2-basic-types2-functions3signatures2md)
*   [JS-UI libs/typescript/2-basic types/2-functions/4.destructuing.md](#js-ui-libstypescript2-basic-types2-functions4destructuingmd)
*   [JS-UI libs/typescript/2-basic types/2-functions/5.constraints.md](#js-ui-libstypescript2-basic-types2-functions5constraintsmd)
*   [JS-UI libs/typescript/2-basic types/2-functions/7.functionOverloads.md](#js-ui-libstypescript2-basic-types2-functions7functionoverloadsmd)
*   [JS-UI libs/typescript/2-basic types/2-functions/8.this.md](#js-ui-libstypescript2-basic-types2-functions8thismd)
*   [JS-UI libs/typescript/2-basic types/5-object-types/a1-4.optProps-interfaces.md](#js-ui-libstypescript2-basic-types5-object-typesa1-4optprops-interfacesmd)
*   [JS-UI libs/typescript/2-basic types/5-object-types/dynamic-keys.md](#js-ui-libstypescript2-basic-types5-object-typesdynamic-keysmd)
*   [JS-UI libs/typescript/2-basic types/5-object-types/object types.md](#js-ui-libstypescript2-basic-types5-object-typesobjecttypesmd)
*   [JS-UI libs/typescript/2-basic types/5-object-types/promise-constructor.md](#js-ui-libstypescript2-basic-types5-object-typespromise-constructormd)

---

## JS-UI libs/typescript/alinks.md

https://www.dslemay.com/blog/2020/04/27/typescript-utility-types-part-1-partial-pick-and-omit

https://egghead.io/lessons/typescript-use-types-vs-interfaces

key phrase

declare global - extends types of typescript

Key type operation

lyn later

https://www.youtube.com/watch?v=-yiQbeB7Bk8&ab_channel=NPRMusic

---

## JS-UI libs/typescript/ts-event.md

Eventlistner - this gets type EventListner?

this.addEventListener('keydown', this.a)

Event handler references the event Object

this.a = (e: Event) => {

â€‹ const a = e.target

}

does Event contain target?

eventListner will only take particular parameters:

-   string?
-   Function?

---

## JS-UI libs/typescript/unknown-never.md

### Unknown

```typescript
let user: any = 4;
user = 'hi';
let user2: unknown = 5;
user2 = 'hi';
let user3: string = 'hi';
user = user3 // ok
user3 = user2 // error: can't assign a non-unknown type to a defined type without type check
user3 = typeof user2 == 'string' ? user2 : JSON.stringify(user2);
```

### Never

```typescript
function ge(message: string) {
    throw { message }
}
ge('hi');
```

---

## JS-UI libs/typescript/10.dom-types/element.md

element / node

https://stackoverflow.com/questions/9979172/difference-between-node-object-and-element-object#:~:text=So%2C%20in%20a%20nutshell%2C%20a,and%20a%20nextSibling%20and%20previousSibling.

Getters

DOMString

when a property doesn't exsit on an object

you can extend its interface

https://stackoverflow.com/questions/38324949/error-ts2339-property-x-does-not-exist-on-type-y

It is because TypeScript 2.7 includes a strict class checking where all the properties should be initialized in the constructor. A workaround is to add the `!` as a postfix to the variable name:

```js
makes!: any[];
```

https://stackoverflow.com/questions/49699067/property-has-no-initializer-and-is-not-definitely-assigned-in-the-construc

extends

https://stackoverflow.com/questions/41385059/possible-to-extend-types-in-typescript

---

## JS-UI libs/typescript/2-basic types/arrays.md

# Arrays

## Two ways of annotating arrays

let arr1: number[] = [];
let arr2: Array<number> = [];

## Mixed Types

```js
const dates = [new Date(), '2030']
```

translates to a variable that is an array that takes strings or date objects (notice parenthesis)

```js
const dates: ( string | Date ) []
```

We can also use the above annotation to override inference that results from this:

```js
const dates = [new Date()]
```

## Tuples

array-like structure where

-   each element represents some properyty of a record.
-   an object called "drink" might have 3 properties: color (string), carbonated (boolean), sugar (number)
-   items in a specific order

```js
var drink = ['brown', true, 40]
```

instead of annotating as an array, we add

```js
const pepsi: [string, boolean, number] = ['brown', true, 40];
```

or we could create a type alias.

```js
type Drink = [string, boolean, number];
const pepsi: Drink = ['brown, true, 40]
```

tuples used with csv's, but still not often used because we can't mark the meaning of items.

## Array of arrays:

```js
const cars = [['a'], ['b']]
or
const care: String[][] = []  // 2-d array
```

**Types in Array.map**

```js
const planets: Object = {
  mercury: { name: "Mercury", position: 1 },
  venus: { name: "Venus", position: 2 },
  earth: { name: "Earth", position: 3 },
};
```

`key` will be a `string` and **map** will return/pass a `string` to the evaulating function body: `planets[key]`

```js
const planetsArr: Array<Object> = Object.keys(planets).map(
  (key: string): string => planets[key]
);
console.log("planetsArr", planetsArr);
```

---

## JS-UI libs/typescript/2-other-types.md/a1-5-union-intersections.md

## Union Types

---

https://www.typescriptlang.org/docs/handbook/2/everyday-types.html

We can build new types called **union types**

They are the result of 2 types **united together**.

The following combines `number` and `string` into a single type:

```
	var id: number | string = '4' // ok
  id = 3; // ok
  id = null; // error
```

The catch:

-   we can pass in a number or string
-   BUT we can only access methods that are shared between both Number and String
    -   for example, `id.toUpperCase()` is only on the string type so wouldn't be availabe on type `string | number`

```ts
function printId(id: number | string) {
  console.log("Your ID is: " + id);
  console.log(id.toUpperCase()); // toUpperCase doesn't exist on type 'string | number'
}
printId(101);//ok
printId("202"); //ok
printId({ myID: 22342 }); // Type {} not assignable to type 'number|string'
```

**The fix**

Narrowing - helps TS deduct type. Here we use the "if/else" to narrow:

```ts
function printId(id: number | string) {
  if (typeof id === "string") {
    // In this branch, id is of type 'string'
		console.log(id.toUpperCase());
  } else {
    // Here, id is of type 'number'
		console.log(id);
  }
}
```

Another example:

```ts
function welcomePeople(x: string[] | string) {
  if (Array.isArray(x)) {
    // Here: 'x' is 'string[]'
    console.log("Hello, " + x.join(" and "));
  } else {
    // Here: 'x' is 'string'
		console.log("Welcome lone traveler " + x);
  }
}
```

## Union

Combine two types using the union operator (`|`).

```typescript
type Combined2 = typeA | typeB;
```

-   Contains properties of either `A` or `B` (not both).

Value may be any one of the listed types.

```typescript
let combine: {name: string | number} = { name: 'x'};
combine = { name: 4 };
```

Use type guards to distinguish which.

### Literal Unions

```typescript
let num: { age: 6 | 7 } = { age: 8 } // incorrect
num = { age: 6 } // correct
```

## Intersection Type

Combine two types using the intersection operator (`&`).

```typescript
type Combined = typeA & typeB;
```

-   Contains properties of both `A` and `B`.
-   In case of objects, the combined object would have properties of both types.
-   The order of types doesnâ€™t matter.

**Assertions: unions and intersections**

TypeScript will only allow you to do things with the union if that thing is valid for *every* member of the union. For example, if you have the union `string | number`, you canâ€™t use methods that are only available on `string`:

```
let a: oz;
let b: oz;
a = { name: 'mel', age: 3 } as (oz & az);

// union: you can assign oz or az to it (not both)
b = { name: 'mel', age: 3 } as (oz | az); // error
```

**intersections**

`interface`s allowed us to build up new types from other types by extending them. TypeScript provides another construct called *intersection types* that is mainly used to combine existing object types.

```
interface Colorful {
  color: string;
}
interface Circle {
  radius: number;
}

type ColorfulCircle = Colorful & Circle;Try
```

Here, weâ€™ve intersected `Colorful` and `Circle` to produce a new type that has all the members of `Colorful` *and* `Circle`.

```
function draw(circle: Colorful & Circle) {
  console.log(`Color was ${circle.color}`);
  console.log(`Radius was ${circle.radius}`);
}

// okay
draw({ color: "blue", radius: 42 });

// oops
draw({ color: "red", raidus: 42 });
```

**interface vs. type + intersection**

-   types can only be extended via intersections
-   interfaces uses teh extended

Since type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types.

---

## JS-UI libs/typescript/2-other-types.md/a1-6-TypeAlias-interface.md

### Type Alias

```typescript
type NumT = {
    age: 6
}

let num3: NumT = {
    age: 7
}; // needs to be 6
```

What is the difference between these statements (interface vs type-alias)?

```js
interface X {
    a: number
    b: string
}

type X = {
    a: number
    b: string
};
```

Interface - extendable; you can add more props later

Type - you can't add more props later

Extending an interface

```
interface Animal {  name: string }
interface Bear extends Animal {  honey: boolean }
const bear = getBear()
bear.name bear.honey
```

Extending type via intersections

```
type Animal = {
  name: string
}

type Bear = Animal & {
  honey: boolean
}

const bear = getBear();
bear.name;
bear.honey;
```

adding new fields to an existing interface

```
interface Window {
  title: string
}

interface Window {
  ts: TypeScriptAPI
}

const src = 'const a = "Hello World"';
window.ts.transpileModule(src, {});
```

a type can't be changed after being created

```
type Window = {
  title: string
}

type Window = {
  ts: TypeScriptAPI
}

 // Error: Duplicate identifier 'Window'.
```

**type alias**

-   creating a new name for an existing type:

```
type Point = {
  x: number;
  y: number;
};

// Exactly the same as the earlier example
function printCoord(pt: Point) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}

printCoord({ x: 100, y: 100 });
```

---

## JS-UI libs/typescript/2-other-types.md/a1-8-literal-types-inference.md

Literal types

```
let x: "hello" = "hello";
// OK
x = "hello";
// ...
x = "howdy";
Type '"howdy"' is not assignable to type '"hello"'.
```

With unions

```
function printText(s: string, alignment: "left" | "right" | "center") {
  // ...
}
printText("Hello, world", "left");
printText("G'day, mate", "centre");
Argument of type '"centre"' is not assignable to parameter of type '"left" | "right" | "center"'.
```

And numbers

```
function compare(a: string, b: string): -1 | 0 | 1 {
  return a === b ? 0 : a > b ? 1 : -1;
}
```

with non-literal types

```
interface Options {
  width: number;
}
function configure(x: Options | "auto") {
  // ...
}
configure({ width: 100 });
configure("auto");
configure("automatic");
Argument of type '"automatic"' is not assignable to parameter of type 'Options | "auto"'.
```

## Literal Inference

https://mariusschulz.com/blog/improved-inference-for-literal-types-in-typescript

include section on constants

Method: "GET" below could be read as a literal type

```
const req = { url: "https://example.com", method: "GET" };
handleRequest(req.url, req.method);
Argument of type 'string' is not assignable to parameter of type '"GET" | "POST"'.
```

There are two ways to work around this.

1.  You can change the inference by adding a type assertion in either location:

```
// Change 1:
const req = { url: "https://example.com", method: "GET" as "GET" };
// Change 2
handleRequest(req.url, req.method as "GET");Try
```

Change 1 means â€œI intend for `req.method` to always have the *literal type* `"GET"`â€, preventing the possible assignment of `"GUESS"` to that field after. Change 2 means â€œI know for other reasons that `req.method` has the value `"GET"`â€œ.

2.  You can use `as const` to convert the entire object to be type literals:

```
const req = { url: "https://example.com", method: "GET" } as const;
handleRequest(req.url, req.method);Try
```

The `as const` suffix acts like `const` but for the type system, ensuring that all properties are assigned the literal type instead of a more general version like `string` or `number`.

---

## JS-UI libs/typescript/2-other-types.md/a1-9-enums.md

## ENUMS

describing a value which could be one of a set of possible named constants. Unlike most TypeScript features, this is *not* a type-level addition to JavaScript but something added to the language and runtime

```JS
const colorRed =0;
const colorBlue = 1
```

```js
enum Color { Red, Green, Blue}  // like Color = {Red: 1, Green: 2, Blue: 3}
let backgroundColor = Color.Blue
```

or

```js
enum Color {Red=0, Blue=1}
```

```js
enum Color {Red, Green, Blue};
```

default values for above 0, 1, 2

but >

```js
enum Color {Red=5, Green, Blue}
let c: Color = Color.Green
console.log(c) // value is 1 .. this returns the item
```

========

## Enums

Enums allow defining a set of named constants.

### Numeric Enums

Initialize `Up` with 1, and the rest auto-increment (`Down` is 2); default initialization is 0.

```typescript
enum Direction {
  Up = 1,
  Down,
  Left
}
```

### Using Enums

```typescript
function response(message: Direction): void {
  console.log(message) // 2
}
response(Direction.Down);
response(2) // Argument of type '2' is not assignable to the parameter of type 'UserResponse'.
```

### String Enums

```typescript
enum UserResponse {
  No = 'n',
  Yes = 'y',
}
```

Usage:

```typescript
const x: UserResponse = 'n'; // won't work
const x: UserResponse = UserResponse.No;

function respond(recipient: string, message: UserResponse): void {
  console.log(message);
  if (message == UserResponse.Yes) console.log('yes');
}

respond("Princess Caroline", UserResponse.Yes );
```

---

## JS-UI libs/typescript/2-other-types.md/object-unknown-never.md

void - return value of functions that don't return a value

`object` - any value that isn't a primitive (ie, string, number, bigint, boolean, symbol, null, undefined)

-   differes from an empty object type or a global type `Object`
-

in JS, function values are objects with properties, etcThus, function types are considered to be `object. in ts

`unknown` - any value, but safer because its not legal to do anything with an unknown value

```
function f1(a: any) {
  a.b(); // OK
}
function f2(a: unknown) {
  a.b();
Object is of type 'unknown'.
}
```

`never. - - values which are never observed.  in a return type, function throws an exception or terminates execution of the program.   Also if nothing left in. a union, never is used.

```
function fn(x: string | number) {
  if (typeof x === "string") {
    // do something
  } else if (typeof x === "number") {
    // do something else
  } else {
    x; // has type 'never'!
  }
}
```

`Function` - global type describing props like bind, call, apply and others present in js function values.

---

## JS-UI libs/typescript/3-narrowing/1.narrowing.md

**Narrowing** - the process of refining types to more specific types than declared

-   how does this differ from down-casting?

**Kinds of narrowing:**

1.  **Truthiness**

https://www.typescriptlang.org/docs/handbook/2/narrowing.html#truthiness-narrowing

Equality

In operator

instance of

---

## JS-UI libs/typescript/3-narrowing/1.typeof type guard.md

**Typeof type gurads**

Typeof to check type so an error doesn't occur

Below, if padding is a string, we would have an error because we can't successfully add a number to a string:

```js
function padLeft(padding: number | string, input: string) {
  if (typeof padding === "number") {
    return new Array(padding + 1).join(" ") + input;
  }
  return padding + input;
}
```

typeof returns lower-cased strings

**Truthiness narrowing**

Now if 0, NaN, "", null, undefined arrive, we get what we need:

```
function getUsersOnlineMessage(numUsersOnline: number) {
  if (numUsersOnline) {
    return `There are ${numUsersOnline} online now!`;
  }
  return "Nobody's here. :(";
}
```

A variation:

```
  if (strs && typeof strs === "object") {
```

---

## JS-UI libs/typescript/3-narrowing/2.typeguards.md

a special form of code called a *type guard*. TypeScript follows possible paths of execution that our programs can take to analyze the most specific possible type of a value at a given position. It looks at these special checks (called *type guards*)

---

## JS-UI libs/typescript/3-narrowing/3.type-guards.md

**User-defined type guard functions**

To define a user-defined type guard, we define a function whose return type is a *type predicate*, which below is `pet is Fish`. `pet` refers to the parameter name, `Fish` is the type.

```
function isFish(pet: Fish | Bird): pet is Fish {
	return (pet as Fish).swim !== undefined;
}
```

If we call the above function with a variable, the function will run as usual, but its return will be *narrowed* to the type referenced in the type predicate if the original compatible

https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates

**The problem**

TS does not recognize `Code` as being a property of `defaultValues[0]`

```ts
    if (defaultValues.length === 0) {
      return selection;
    }

    if (defaultValues.length === 1 && defaultValues[0]['Code'] === 'All') {
```

How to fix this?

```ts
// Type Guard - check if item is an object with a Code property, then return the boolean but also reconfigure the parameter so that its typed `DeperecatedSiteModel`
const isSite = (site: unknown): site is DeprecatedSiteModel => (
  typeof defaultValues[0] === 'object' && 'Code' in defaultValues[0]
);
// 1. copy to firstItem - why because defaultValues is a string[]; firstItem has no type.  Also, we might not want to change the type of defaultValues
const firstItem = defaultValues[0];
// 2. pass it to to the type guard; if it passes, we can run the rest of the checks, including the `firstItem.Code`
if (isSite(firstItem) && defaultValues.length === 1 && firstItem.Code === 'All') {
  return selection;
}
```

How to read this:

\_selectDefault is a generic function, which takes two arguments, arrays ofhte same sort. This also returns an array. We would defined this sort when we called the function:

```js
private _selectDefault<T>(selection: T[], defaultValues: T[]): T[] {
	if (defaultValues.length === 0) {
		return selection;
  }

// Type Guard - this translates defalutValues[0] as DeprecatedSiteModel // this actually returns true or false, right?
   const isSite = (site: unknown): site is DeprecatedSiteModel => (
    	typeof defaultValues[0] === 'object' && 'Code' in defaultValues[0]
    );

    const firstItem = defaultValues[0];
  // why not pass defaultValues[0] into isSite? because we are not recasting defaultValues, but `site is Dep..` actually recasts?? becaue we're recasting a newvariable?
  // if defaultValues has
    if (isSite(firstItem) && defaultValues.length === 1 && firstItem.Code === 'All') {
      return selection;
    }
  // now we can check ...
  // check the repo to see what's old and what's not...
    if (defaultValues.length === 1 && defaultValues[0].Code === 'All') {
      return selection;
    }
    return defaultValues;
  }
```

**TypeParamter**

```js
private _selectDefault<T>(selection: T[], defaultValues: T[]): T[] {
```

The function `_selectDefault` is a "generic function" because it carries the `<T>` after the function name, which indicates that it will be using this generic type T throughout the function when referenced.

In this case, if we pass in an array of objects, T would indicate object.

`: T[]` indicates that will will return an array of T

**Problem one**

This would be an issue because if `defaultValues` is an array of objects, each object would be of type of object, which lacks a `Code` property.

` if (defaultValues.length === 1 && defaultValues[0].Code === 'All') {...}`

How to fix? TypeGuard, which is a narrowing techinque: We translate the type of defaultValues object[] to that of `DeprecatedSiteModel` which does contain `Code`.

This function will take a value (that is typed as unknown, meaning we can offer a range of types.

Unknown is a flexible type; however, it has limits in that it can only be recast as another unknown or as any?

and then recasts it as `DeprecatedSiteModel` - which does have a property called `Code`

â€œIsâ€ is used for typesetting

```ts
   const isSite = (site: unknown): site is DeprecatedSiteModel => (
    	typeof defaultValues[0] === 'object' && 'Code' in defaultValues[0]
    );

```

We pass in our defaultValues:

```ts
const firstItem = defaultValues[0];
```

To do this we use a "Type Guard", indicated by `isSite. `

`const* firstItem = *defaultValues*[0];`

What is returned is a - what is returned?

defaultValues[0] is type object, but we save it as firstItem, whihc is typed DeprecatedSiteModel, which has Code on it.

Doing this, TS can recognize Code on firstItem

Notes

So this returns site as DeprecatedSiteModel where it was type unknown before.

Question about generics

```tsx
#### export default *class* CsScrollableTabBar<ItemType> extends LitElement {
  @property({ type: *Array* })
  items: ItemType[] = [];

  @property({ type: *Object* })
  tabRenderer = (*item*: ItemType) *=>* (typeof *item* === 'string' ? *item* : '');

  @property({ type: *Object* })
  tabIconRenderer = (*item*) *=>* null;
```

Yep, in this case, `ItemType` is a generic and `tabRenderer` should return a string. If we detect that the item passed in is a string then we can go ahead and use that within the default `tabRenderer`. Otherwise, the user should provide a custom `tabRenderer`.

---

## JS-UI libs/typescript/3-narrowing/4.intersect-strategy.md

Functions

```js
function merge(a: object, b: object) {
  return Object.assign(a, b);
}

const mergeObj = merge({name: 'max'}, {age: 5})
```

the function can't access mergedObj.age because its typed as object and `age` is not a property of the `object` type.

we can type case: merge() as {name: string, age: number}

An alternative:

```ts
function merge<T, U>(a: T, b: U) {
  ....
}
```

infers that this function merges the intersection of a + be

```ts
function merge<T, U> (a: T, b: U): T & U
```

T will know its an object with specific keys
types set dynamically when its called.
T will vary depending on what's being passed in.

we can also do this

```
function merge<{name:string}, {age: number}> ....
```

but generics do this.

If we want to restrict the generic type via type contrainsts:

`function merge<T extends object>(obj: T)` ... now obj must be an object

we can pass a string or array:

```
function count<T>(el: T) {
  let des = 'no value';
  if (el.length > 1 ) des = got many des
  if (el.length === 1) des = got one des
  return [el, des];
}
```

above complains about length b/c its not clear that el has a length method
so we create an interface.

```
interface len {
  length: number;
}
```

then above we extend T - also, we note return...

`function count<T extends len>(el: T): [T, string]`

via len, we have told typescript that T has a method...

this creates an error bc obj could be {} which has no keys:

```
function extract(obj: object, key: string) {
  return obj[key]
}
```

so use generic

```
function extract< T extends object, U extends keyof T>(obj: T, key: U)
```

key should be a key of obj - if its not.

---

## JS-UI libs/typescript/3-narrowing/6-assignments.md

**Assignments**

when we assign to any variable, TypeScript looks at the right side of the assignment and narrows the left side appropriately. Assignability checked against the declared type

```tsx
const a = 'hi'

let x: string | number =  a === 'hi' ? 1 : 'goodbye'

x= true; // error

Type 'boolean' is not assignable to type 'string | number'.
```

**Control flow analysis**

TS uses this to narrow types as it encoutners typeguards an dassignments

so for a function that accepts number | string,

so as it encoutners an "if statement" for "numbers", it will deduct that the type is strings

```
function example() {
  let x: string | number | boolean;

  x = Math.random() < 0.5; // boolean

  if (Math.random() < 0.5) {
    x = "hello"; // string
  } else {
    x = 100; // number
  }
  return x; //
}
const y = example() // y will be number if the random number is greater than .5
```

**Type Predicates**

Type predicates in TypeScript help you narrow down your types based on conditionals: if a function returns true, change the type of the paramter to something more useful.

Theyâ€™re similar to type guards, but work on functions.

Typical Type Checking

Here, we use `isString` to check the type: it will return `true` if type is `string`

```typescript
function isString(s) {
  return typeof s === 'string';
}
```

We can use it to check if its a string, but we'll still get an error because its type unknown

But below, the validation is wrapped in a function, so the type of x doesn't change as it does it type guards..

```typescript
function toUpperCase(x: unknown) {
  if(isString(x)) {
    x.toUpperCase(); // âš¡ï¸ x is still of type unknown
  }
}
```

So re-write the validator as a function whose return type is a type predicator - this will change the type of string, if it's posssible. Below `s is string` is the type predicate.

```typescript
function isString(s): s is string {
  return typeof s === 'string';
}
```

The above says that you plan to return `s` as a `string` ONLY IF its typeof value is `string`. Define a function whose return type is a type predicator

Example 2

Here we check to see that pips is not only a number, but a certain number 1-6

```typescript
function pipsAreValid(pips: number) {

  return pips === 1 || pips === 2 || pips === 3 ||
    pips === 4 || pips === 5 || pips === 6;
}
```

Here, we use the validator:

```typescript
function evalThrow(count: number) {
  if (pipsAreValid(count)) {
    // my types are lying ðŸ˜¢ - count is not technically a number but a kind of number
    switch (count) {....
```

Rewrite teh validator so it changes the type to a "kind of number"

```typescript
type Dice = 1 | 2 | 3 | 4 | 5 | 6;

function pipsAreValid(pips: number): pips is Dice {
  return pips === 1 || pips === 2 || pips === 3 ||
    pips === 4 || pips === 5 || pips === 6;
}
```

---

## JS-UI libs/typescript/3-narrowing/7-discriminated-unions.md

Discriminated uniosn

When every type in a union contains a common property with literal types, TypeScript considers that to be a *discriminated union*, and can narrow out the members of the union.

In this case, `kind` was that common property (which is whatâ€™s considered a *discriminant* property of `Shape`). Checking whether the `kind` property was `"circle"` got rid of every type in `Shape` that didnâ€™t have a `kind` property with the type `"circle"`. That narrowed `shape` down to the type `Circle`.

We want kind to tell us what shape we're dealing with - circle or square.

```typescript
interface Shape {
  kind: "circle" | "square";
  radius?: number;
  sideLength?: number;}
```

`kind` represents a union of **string literal types** . This helps us have a unique type and avoids misspellings

```typescript
shape.kind === 'rect' /// will always be false since types `circle | square` and `rect` have no overlap.
```

Error : radius might not be defined (it's optional)

```typescript
function getArea(shape: Shape) {
  return Math.PI * shape.radius ** 2;
Object is possibly 'undefined'.
}
```

Even with a check -

```
function getArea(shape: Shape) {
  if (shape.kind === "circle") {
    return Math.PI * shape.radius ** 2;
Object is possibly 'undefined'.
  }
}
```

How to ensure that radius or sideLength are present based on the kind property? Here we re-encode Shape

```typescript
interface Circle {
  kind: "circle";
  radius: number;
}

interface Square {
  kind: "square";
  sideLength: number;
}

type Shape = Circle | Square;
```

Now it knows That if its a circule, it will not have a sideLength property.

Use that with a conditional to ensure its a circle, and the error goes away:

```typescript
function getArea(shape: Shape) {
  if (shape.kind === "circle") {
    return Math.PI * shape.radius ** 2;

(parameter) shape: Circle
  }
}
```

---

## JS-UI libs/typescript/7-classes/11.classes.md

## Classes

classes - blueprints to create an object wtih felds and functions to represent a thing

```js
class Vehicle {
  drive(): void {
    console.log("hi")
  }
  honk(): void {
    console.log("now")
  }
}

const my_car = new Vehicle();

class Van extends Vehicle {  // extends copies Vehicle
  honk(): void{
    console.log("we") // this will override the previous honk
  }
}
```

TS classes a little different than in ES6

modifiers - key words we can use. here are 3:

-   public - method accessible anywhere any time
-   private - methods accessed ONLY by other methods of same class
-   protected - methods called yby other methods in this class OR by those in child classes

---

## JS-UI libs/typescript/7-generics/0.generics.md

Generics let us pass in any type:

a component that can work over a variety of types rather than a single one.

TypeScript Generics is a tool which provides a way to create **reusable** components. It creates a component that can work with a **variety of data types** rather than a single data type. It allows users to consume these components and use their own types. Generics ensures that the program is flexible as well as scalable in the long term.

https://www.javatpoint.com/typescript-generics

We use the type `any` twice: both for the param & return:

```tsx
function identity(arg: any): any {
  return arg;
}
```

This is the same, but allows us to "pass in the type". Now the user can pass in `number` or `string` and all is strictly typed

```tsx
function identity<Type>(arg: Type): Type {
  return arg;
}
```

Call the function,passing in an explcit type

```tsx
let output = identity<string>("myString");
```

call function, allowing for type inference:

```tsx
let output = identity("myString");
```

Next - generic types.

---

## JS-UI libs/typescript/7-generics/1.ang-brackets.md

## **When are angle brackets <> used?**

**When definining generics ~ they are used to accept arguments, like () accept args in functions**

It brackets are placed between the name + parenthesis/curly brackets

Below we are creating flexibility ~ asking the user of `identity` to supply the type.

only use a generic if you intend to use the parameter in multiple places? Below we use it to define the argument and return value:

```
function identity<T>(arg: T): T {
  return arg; // we cannot return a number in this instance
}
identity<string>("hello") // user supplies type string
```

**As alternative syntax for type assertion**

Is type-casting a synonym for type-assertion ?

Two ways of asserting type:

-   `as val` after the literal
-   `<any>` before the literal

```ts
let a = 1 as any;
let a = <any>1;
```

```
let square = <Square>{};
let square = {} as Square;
```

Example:

```ts
interface Props {
    x: number;
    y: number;
    name: string;
}

let a = {};
a.x = 3; // error: Property 'x' does not exist on type `{}`
```

Instead:

```
let a = {} as Props;
a.x = 3;

//or

let a = <Props> {};
a.x =3;
```

---

## JS-UI libs/typescript/7-generics/1.generics what.md

**Example one**: Arrays

Two ways to declare an array:

-   **sqare brackets** - let fruits: number[] = [1, 2, 3]
-   **generic array type** - let fruits: Array<number> = [1, 2, 3]

**sqaure brackets**:

this might be called with <number>([1, 2, 3]) which means the argument would have type `number[]` However, there is no `length` on array.

```js
function loggingIdentity<T>(arg: T[]): T[] {
    console.log(arg.length);
    return arg;
}
```

**generic brackets:**

```js
function loggingIdentity<T>(arg: Array<T>): Array<T> {
    console.log(arg.length);
    return arg;
}
```

---

## JS-UI libs/typescript/7-generics/1.generics-builtIn.md

## \_\_Built-in Generics\_\_: Arrays + Promises

**Array**

This is a kind of type called a 'generic'
it requires one type argument
a type connected to another type
generic types require more info via arguments

```
const names: Array<string> = [];
```

same as

```
const names: string[];
```

for both, this will display all the string methods:

```
names[0]. <---- string methods will now appear
```

**Promise**

A promise that will resolve a string.

```ts
const promise = new Promise<string>((resolve, reject) => {
  ....resolve('hi') <-return a string
})

promise.then(data => {
  data.  <- ts knows this will be a string
})
```

and below ~ using Promise to show return type

```typescript
async function fetchApi<ResultType>(path: string): Promise<ResultType> {
  const response = await fetch(`https://example.com/api${path}`);
  return response.json();
}

const data = await fetchApi<User[]>('/users')
```

and

```js
function test(arg: string): Promise<number> {
    return new Promise<number>((resolve, reject) => {
        if (arg === "a") {
            resolve(1);
        } else {
            reject("1");
        }
    });
}
```

---

## JS-UI libs/typescript/7-generics/2.generic-func.md

FROM MAX 99

Problem

```
function merge(objA: object, objB: object) {
  return Object.assign(objA, objB)
}

const data = merge({name: 'max'}, ...)


```

it won't know that `data` has a `name` key.

we could typecast - what we get back is an object with certain keys:

```
const data = merge({name: 'max'}, ...) as {name: string, age: number}
```

OR

```
function merge<T, U>(objA: T, objB: U): T & U { .... }
```

Now when you call teh funciton, it will set these types dynamically

this will fill in different type for each instance

```
const data = merge(...)
```

We could pass in specific types if we don't want variability:

```
const data = merge<{name: number}, {age: number}>({name: 2}, {age: 2})
```

Restrict T U to be objects, but not define the kind of object:

```
function merge<T extends object, U extends object>
```

T can be any type of any structure, but must be an object

Example 2

Below, it complains that element does not have length, so create an interface

```
function countAndPrint<T>(element: T) {
  let description = 'got no value';
  if (element.length > 0) {
    description = ` got ${element.length} element
  } else if (element.lnegth > 1) {
    description = `ljl`,
  }
  return [element, description]
}
```

Revised

```
interface Lengthy {
  length: number
}
```

It takes a property that has a length prop
It returns an array that has the same prop + string

```
function countAndPrint<T extends Lengthy>(element: T): [T, string] { ...
```

now we can call with string, array, but not a number because a number doesn't have a 'length' property

Another constraint: "keyof"

```
function extract(obj, key) {
  // this returns a particular key in the object
    return obj[key]
}
```

```
const ace = extract({name: 'max'}, 'name')
// returns 'max', a string
console.log(ace)


```

PROBLEM:

```
function extract(obj: object, key: string) {
  return obj[key] // problem: object, doesn't have key of string
}
```

Here, we'll take
- any type so long as its an object,
- any type, so long as its a key in that object

```
function extract<T extends object, U extends keyof T>(obj: T, key: U) {
  return obj[key] // problem: object, doesn't have key of string
}
```

Stopped at max 99

---

## JS-UI libs/typescript/7-generics/2.generic-funcs.md

**Generics**

The problem:
This takes an array composed of any items
But when I USE this array, I don't know if the items are strings, numbers, or what.
How can I convey this?

```tsx
function firstElement(arr: any[]) { // array could consist of any type
  return arr[0]; // how to define a type for this?
}
```

Instead, we can use a TYPE VARIABLE, which holds a TYPE.

-   it is like a function parameter which uses <> instead of ()
-   it takes a data type

BELOW: We declare

-   firstElement<Type> - we declare the type varaible
    We always use it in at least 2 places:
-   arr: Type[] - our array will consist of Type
-   : Type - we will return the same type

```tsx
function firstElement<Type>(arr: Type[]): Type {
	return arr[0]
}
```

THEN, we need to pass in our type.

-   firstElement takes 1) a type (string) + 2) a value (array)

```js
let output = firstElement<string>(['1', '2'])
```

Now when we return to our function, we know that the array will be filled with strings

**An example**

-   function takes a type
-   it uses type to define 1) argument + 2) return (the call signature)
-   we "call" this with the argument `number`

```ts
function observable<T>(y: T): T {
    let a: T = 5; // no ~ you wouldn't use T here; use number
    let x = y
    return x;
}
let st = observable<number>(4)
```

**Type Inference**

We don't use generics if TS can easily infer the type (as above)

**Multipe type parameters in map:**

type parameters: input, output
function parameters: arr, func
func uses input, output in its callsignature (function type)

```tsx
function map<input, output>(arr: input[], func: arg(input) => output) : output[] {
	return arr.map(func)
}
```

Below does not require generics since it can be inferred

```js
// Parameter 'n' is of type 'string'
// 'parsed' is of type 'number[]'
const parsed = map(["1", "2", "3"], (n) => parseInt(n));
```

---

## JS-UI libs/typescript/7-generics/3.generic-obj.md

**Generics**

-

**objects**

generics are often used with `type` or `interface` that defines the object.

```ts
type genObj<T> = {
	contents: T;
}
// this won't work - instead assign on same line?
// let xaa:genObj<number>;
// xaa.contents = 6;

let xaa: genObj<number> = {contents: 5}
```

Arrays

---

## JS-UI libs/typescript/7-generics/generics3.md

Summary
Combinations

-   generics
-   constraining a function
-   keyof
-   Indexed-access type

---

## Creating Types from Types

### Generics

-   Types that take parameters.
-   Defined using angle brackets (`<>`).
-   Can be used with the `function` keyword or as a `const` with an optional name.
-   The generic tag comes after the optional name.
-   Used to set the type, similar to how a parameter sets an argument.

```typescript
function identity<Type>(arg: Type): Type {
  return arg;
}
```

-   Allows capturing the type the user provides.
-   Two ways to pass a type to a generic function:
    -   Explicitly set the type: `let output = identity<string>("myString");`
    -   Type argument inference: `let output = identity("myString");`

-   Call signature of an object literal type:

```typescript
let myIdentity: { <Type>(arg: Type): Type } = identity;
```

### Generic Interface

-   Can be used to create a generic interface.

```typescript
interface GenericIdentityFn {
  <Type>(arg: Type): Type;
}

let myIdentity: GenericIdentityFn = identity;
```

-   Move the generic parameter to be a parameter of the whole interface.

```typescript
interface GenericIdentityFn<Type> {
  (arg: Type): Type;
}

let myIdentity: GenericIdentityFn<number> = identity;
```

### Constraining a Function

-   Constrain a function to work with any type that has the `.length` property using the `extends` keyword.

```typescript
interface Lengthwise {
  length: number;
}

function loggingIdentity<Type extends Lengthwise>(arg: Type): Type {
  console.log(arg.length); // No more error
  return arg;
}
```

-   Example usage: `loggingIdentity(3); // Error: Argument of type 'number' is not assignable to parameter of type 'Lengthwise'`.

### Using Type Parameters in Generic Constraints

-   Stopped
-   Next

---

## JS-UI libs/typescript/7-generics/genertics2.md

next

https://www.typescriptlang.org/docs/handbook/2/functions.html

next p2

\_\_generics\_\_

## Objects: Defined

for objects, you need to use type / interface

```tsx
type GenericType<T> {
  value: T
}

type NormType = {
  value: string;
}
```

### Objects: Use

```tsx
const x: NormType = { value: 'hi'};
const x: GenericType<string> = { value: 'hi'}
```

### Functions: defined

```tsx
const x = (y) => y

const functionName = <T>(parameters): ReturnType => {
  // function body
}

const x = <T>(y: T): T => y;

const result = x<string>('hi')
```

but could also rely on inference

```jsx
const result = x('hi');
```

and even without the generic definition, it would infer.

so why use it? in cases where there might be more complex functions where type inference is not sufficinet alone. Like, here item could differ from the items in array, but this enforces they be the same:

```tsx
function addItemToArray<T>(array: T[], item: T): T[] {
  return [...array, item];
}
```

---

## JS-UI libs/typescript/9-reference/compatibility.md

## Compatiblity

https://www.typescriptlang.org/docs/handbook/type-compatibility.html

x is compatible with `y` if `y` has at least the same members as x

Below, `dog` is compatible to `Pet` because it shares `name: string` -

```ts
interface Pet {
  name: string;
}
let dog = { name: "Lassie", owner: "Rudd Weatherwax" };

function greet(pet: Pet) {
  console.log("Hello, " + pet.name);
}
greet(dog); // OK because paramter pet requires at least name, and dog has that.
```

Comparing Two Functions

Parameter types

```ts
let x = (a: number) => 0;
let y = (b: number, s: string) => 0;
y = x; // OK because all x parameters have a corresponding type in y
x = y; // Error because x does not have a string parameter.
// names of parameters unimportant.
```

return types

```
let x = () => ({ name: "Alice" });
let y = () => ({ name: "Alice", location: "Seattle" });
x = y; // OK b/c x can discard location
y = x; // Error, because x() lacks a location property
```

---

## JS-UI libs/typescript/9-reference/partials.md

a partial is a "utility type"

Constructs a type with all properties of `Type` set to optional. This utility will return a type that represents all subsets of a given type.

```
interface Todo {
  title: string;
  description: string;
}

function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {
  return { ...todo, ...fieldsToUpdate };
}

const todo1 = {
  title: "organize desk",
  description: "clear clutter",
};

const todo2 = updateTodo(todo1, {
  description: "throw out trash",
});
```

other example

```
const payload: Partial<Study> = {

â€‹    ...convertStudyModelToStudy(study),

â€‹    Status: InternalStudyStatuses.FinalPending,

  };
```

---

## JS-UI libs/typescript/typescript-react/0.getting-started.md

npx create-react-app <app-name> --template typescript

https://react-typescript-cheatsheet.netlify.app/docs/basic/setup

---

## JS-UI libs/typescript/typescript-react/1.props-state.md

Child props

How to define a react component?

\_\_Approach 1: define the custom props\_\_

```jsx
interface ChildProps {
  color: string
}

export const Child = ({color}: ChildProps) => {
  return <div>{color}</div>
}
```

But the component has built-in props, such as:

```jsx
propTypes, displayName, defaultProps, contextTypes
```

and children:

```jsx
Child.propTypes
```

\_\_Approach 2: use React.FucntionComponent\_\_

React.FC<> is a generic
pass in custom props:

```jsx
export const Child: React.FC<ChildProps> = ({color}) => {
  return <div>{color}</div>
}
```

With a callback:

```jsx
interface ChildProps {
  color: string,
  onClick: () => void  // not expecting a return
}
```

\_\_problems with React.FC\_\_

-   explict about return type (usually its implicit)
-   it provides typechecking and autocomplete for staic props like displayName, etc
-   doesn't support conditional rendenring

https://www.harrymt.com/blog/2020/05/20/react-typescript-react-fc.html

https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example

\_\_alternatives\_\_

---

## JS-UI libs/typescript/typescript-react/2.state.md

const [name, setName] = useState('') // via inference, it applies type string
const [guest, setGuests] = useState([]) // not enough information to infer...

setGuests([...guests, name])

Tell TS what kind of []

const [guest, setGuest] = useState<string[]>([])

We could also use a generic type
and write out all possible types wihtin:

useState<{name: string, age: number} | undefined>

Now we know this state will be undefined if a user is not foudn...

---

## JS-UI libs/typescript/2-basic types/2-functions/0.syntax.md

## Syntax

1.  function expression:

```js
function Sum(x: number, y: number) : number {
    return x + y;
}
```

2.  anonymous function:

```js
let Sum = function(x: number, y: number) : number {
    return x + y;
}
```

3.  arrow functions: `name = (parameters) => {statement}`
    -   parenthesis for 2+ parameters; brackets from 2+ lines

```js
let sum = (x: number, y: number): number => {
    return x + y;
}
```

4.  anonymous arrow:

```
(x, y) => x+y

((x, y) => x+y)(3, 4) // 7
```

5.  function constructor:

```tsx
const person = new function() {this.name = 'john'};
console.log(person);

const person =
```

---

## JS-UI libs/typescript/2-basic types/2-functions/1.parameters.md

Functions

**two types of annotations in function declaration**

-   Parameter type annotation (number)
-   Return type annotation (number)

```typescript
(a: number, b: number): number => a + b
```

**Parameters**

Optional Parameters (Question mark after name)

When writing a function type for a callback, *never* write an optional parameter unless you intend to *call* the function without passing that argument

```ts
function Greet(greeting: string, name?: string ) : string {
    return greeting + ' ' + name + '!';
}
```

Default Parameters (string = "Hello")

```ts
function Greet(name: string, greeting: string = "Hello") : string {
    return greeting + ' ' + name + '!';
}
```

Rest Parameters (will take multiple arguments as an array of strings)

-   rest parameters must come last (one per function)
-   Args must be of same type

```ts
function Greet(greeting: string, ...names: string[]) {
    return greeting + " " + names.join(", ") + "!";
}
```

```js
function ace(...age:number[]) // number will equal [1, 2, 3]
ace(1, 2, 3)
```

**Rest vs arguments**

arguments object contains

-   numbered properties whose values are the arguments
-   length property: number of parameters
-   Callee prop: name of the function

arugments is not a real array, but it could be converted into one:

```js
var args = Array.prototype.slice.call(arguments);
// Using an array literal is shorter than above but allocates an empty array
var args = [].slice.call(arguments);
```

(What is the difference between a function / method?)

**Using arguments to mimic overloading**

```js
 function sendGreetingTo(to, greeting) {
     if(arguments.length == 1) {
         console.log('Hi, ' + to);
     } else if (arguments.length == 2) {
         console.log('Hi, ' + to + ' ' + greeting);
     }
 }

   sendGreetingTo('Breuer');                                 //Hi Breuer
   sendGreetingTo('Breuer', 'Its nice to see you again');    //Hi Breuer Its nice to see you again
```

---

## JS-UI libs/typescript/2-basic types/2-functions/2. signatures.md

**TS call signature** aka function type

Using non-arrow functoin: accept a number type and return a boolean type

```ts
(someArg: number): boolean;
```

Using arrow function: accept a string type and return nothing

```ts
(a: string) => void
```

** function type expressions**

We can create a type and use it later

```ts
type GreetFunction = (a: string) => void;
```

Use it as part of an interface

```js
interface MyInterface {
    (x:number, y:string):string;   // this is an anonymous function? non-arrow format
    someProperty: (x:number, y:number)=>number;  // named arrow format
}
```

Use it in the parameter itself:

```
function greeter(fn: (a: string) => void) {
 	fn('hello')
}
```

Use its pre-defined type in the parameter:

```
function greeter(a: GreetFunction) { ...}
```

**Constructor Signatures**

A constructor

```
const x = new Owner('Mike')
```

Type:

```
new (s: string): Obj;
```

`new` implies its a constructor that takes a string and returns an object:

```tsx
type Cnstr = {
new (s: string): Obj;
}
function fn(ctr: Cnstr) {
return new ctr('hello')
}
```

Some constructors can be called with or without new:

```
interface callorconstruct {
new(s: string): Date;
(n?: number): number
}
```

---

## JS-UI libs/typescript/2-basic types/2-functions/3.signatures2.md

**A function type expression (reminder)**

```
(Parameters: type) => return
```

Here, we pass in an array and a function (callback):

```tsx
function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i);
  }
}
```

The function passed in:

(arg: any, index?: number) => void

This is a function that takes 2 arguments

-   any
-   an optional number

**Call Signatures**

```js
interface MyInterface {
   // This is call signature
   // It is used inside object type, function expression, function declaration, etc...
    (x:number, y:number):number;
}
```

Functions can

-   have properties (like Objects);
-   be callable

For example

```ts
function hello(a: number): boolean {
  return true;
}

hello.description = '35'
```

Yet function type expression syntax doesn't allow for declaring propserties.

what is a function type experession? This, which doesn't leave room for defining `descripton`:

```ts
(a: string): number;
```

Well, we can create a type alias, and assign it to the function parameter:

```ts
type DescribableFunction = {
  description: string;
  (someArg: number): boolean;
};

function doSomething(fn: DescribableFunction) {
  console.log(fn.description + " returned " + fn(6));
}
```

now, call the functino:

```ts
doSomething(hello)
```

However, what if we add the property via `this`?

**part two**

```ts
type DescribableFunction = {
  (someArg: number): boolean;
  description: string;
};

function doSomething(fn: DescribableFunction) {
  console.log(fn.description + " returned " + fn(6));
}

type X = {
  description: string
}

function hello(this: X, num: number): boolean {
  this.description = '35';
  return true;
}

doSomething(hello)
```

Results:
// Argument of type '(this: X, num: number) => boolean' is not assignable to parameter of type 'DescribableFunction'.
// Property 'description' is missing in type '(this: X, num: number) => boolean' but required in type 'DescribableFunction'.

Solution

**Construct Signatures**

```
type SomeConstructor = {
  new (s: string): SomeObject;
};
function fn(ctor: SomeConstructor) {
  return new ctor("hello");
}
```

---

## JS-UI libs/typescript/2-basic types/2-functions/4.destructuing.md

Tuples

```
// Inferred as 2-length tuple
const args = [8, 5] as const;
// OK
const angle = Math.atan2(...args);
```

**Destructuring**

```
function sum({ a, b, c }) {
  console.log(a + b + c);
}
sum({ a: 10, b: 3, c: 9 });
```

The type annotation for the object goes after the destructuring syntax:

```
function sum({ a, b, c }: { a: number; b: number; c: number }) {
  console.log(a + b + c);
}
```

This can look a bit verbose, but you can use a named type here as well:

```
// Same as prior example
type ABC = { a: number; b: number; c: number };
function sum({ a, b, c }: ABC) {
  console.log(a + b + c);
}
```

---

## JS-UI libs/typescript/2-basic types/2-functions/5.constraints.md

**Constraints**

Sometimes we want to

-   relate two values AND
-   **restrict** which values those might be

We can do this via a **extends** clause. This function does the following:

-   recieves two arguments of type `Type`
-   however, `Type` must have a `length` property whose type is `number`
-   Here, we ensure that Type must have a property length:

```tsx
function longest<Type extends { length: number }>(a: Type, b: Type) {
  if (a.length >= b.length) {
    return a;
  } else {
    return b;
  }
}
```

Now see the results. What data types contain a built-in length property?

-   Array and string
-   but not Number:

```
// longerArray is of type 'number[]'  This has an Array, which has a length property, so OK
const longerArray = longest([1, 2], [1, 2, 3]);
// longerString is of type 'string'
const longerString = longest("alice", "bob");
```

TS infers the return type of `longest`

-   without the extends, we wouldn't be able to access `length` prop of parameters a and b
-   `longerArray` and `longerString` are inferred based on arguments

```
// Error! Numbers don't have a 'length' property
const notOK = longest(10, 100);
Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.
```

**Specifying Types**

This function takes 2 arguments with these constraints:

-   they must be arrays
-   the array items must be of the same type

And it returns an array whose items are of the same type

```tsx
function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
  return arr1.concat(arr2);
}
```

Here, the 2 array have different types of array items:

```
const arr = combine([1, 2, 3], ["hello"]);Type 'string' is not assignable to type 'number'.Type 'string' is not assignable to type 'number'.
```

However, you could manually set `Type`

So into the type parameter `<Type>` , we are passing in this type argument: `<string | number>`

```
const arr = combine<string | number>([1, 2, 3], ["hello"]);
```

Which is like saying:

```tsx
function combine<string|number>(arr1: string|number[], arr2: string|number[]): string|number[] {
  return arr1.concat(arr2);
}
```

**Some Guidelines for Generic Functions**

-   When possible, use the type parameter itself rather than constraining it because the constraint could reduce the specifity of the type

-   Always use as few type parameters as possible / Make sure a generic type parameter does indeed relate tow values

-   If a type parameter only appears in one location, strongly reconsider if you actually need it

---

## JS-UI libs/typescript/2-basic types/2-functions/7.functionOverloads.md

**Overloads**

One thing to note is that a *function* signature allows *overloading*:

```js
var myTwo : {
    (x:number, y:number):number;
    (x:number):string;
}
```

Which is not supported for a `property` annotation.

**Function Overloading** - the next definition is wrong - look it up on axel

If 2 functions have the same name and same number of parameters, but different parameter types and return type.

```ts
function add(a:string, b:string):string;

function add(a:number, b:number): number;

function add(a: any, b:any): any {
    return a + b;
}

add("Hello ", "Steve"); // returns "Hello Steve"
add(10, 20); // returns 30
```

Unusal > what is this?\*\*

-   `log` takes a number, returns nothing

-   after `=` the function begins:

```ts
  const log: (i: number) => void = (i: number) => {
  }
  ```

-   always annotate functions since args have not type inference.

-   annotate using form `parameter : type`

-   return does use infernece, but we don't use it.. b/c it helps us catch mistakes

-------

What if we have a function that can take either 1 argument in on situation or 3 in another.

We specifiy this via overload sigantures.

Just write 2+ function signatures, followed by the body of the function:

```tsx
function makeDate(timestamp: number): Date;  /// in case its called with 1 argument
function makeDate(m: number, d: number, y: number): Date; // overload sig1: 3 arguments
function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {  // the implementation signature
  if (d !== undefined && y !== undefined) {
    return new Date(y, mOrTimestamp, d);
  } else {
    return new Date(mOrTimestamp);
  }
}
const d1 = makeDate(12345678);
const d2 = makeDate(5, 5, 5);
const d3 = makeDate(1, 3);
No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.
```

In the above case, the implementation signature reflects the either/or case presented by teh overload signatures

Remember

The signature of the *implementation* is not visible from the outside. When writing an overloaded function, you should always have *two* or more signatures above the implementation of the function.

The implementation signature must also be *compatible* with the overload signatures.

the implementation signature must match the overloads in a correct way

**Writing good overloads**

> Always prefer parameters with union types instead of overloads when possible

Here, we can accept a string or an array, but not either/or

```
function len(s: string): number;
function len(arr: any[]): number;
function len(x: any) {
  return x.length;
}
```

so this won't work:

```
len(Math.random() > 0.5 ? "hello" : [0]);
```

Use the union instead:

```
function len(x: any[] | string) {
  return x.length;
}
```

***Overloaded functions** are functions having the same name but different signatures, that is, the number of the arguments.*'

This doesn't exist in JS, but it does in Java where you can have multiple function of same name but different arguments.

In JS, if 2 functions are defined with same name, then the last defined function will over write teh former.

In JS, we mimic function overloading this way:

-   you can write a class the returns the right function depending on the number of arguments passed in
-   you can write a function that counts the arguments and acts accordingly or uses optional arguments

---

## JS-UI libs/typescript/2-basic types/2-functions/8.this.md

This

```
const user = {
  id: 123,
  admin: false,
  becomeAdmin: function () {
    this.admin = true;
  },
};
```

Remember, a call signature looks like this:

(Parameter:type) => return

(arg: number) => boolean

Lets say you want more control over what object `this` represents. Since we can't have a parameter called this, TS uses that word to le us declare the type for this in the function body

-   filterUsers is a function that takes 1 parameter (filter)
-   as the parameter's type, we can define this as User
-   this function will return a boolean
-   filterUsers returns User[]???

```
interface DB {
	filterUsers(filter: (this: User) => boolean): User[];
}

const db = getDB();
const admins = db.filterUsers(function (this: User) {
  return this.admin;
});
```

---

## JS-UI libs/typescript/2-basic types/5-object-types/a1-4.optProps-interfaces.md

## Interfaces

Creates a new type, describing property names and value types of an object

This is the norm:

```js
// The parameter's type annotation is an object type
function printCoord(pt: { x: number; y: number }) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}
printCoord({ x: 3, y: 7 });
```

OR use an interface

```js

// interface takes a capital initial letter

interface Vehicle = {
  name: string;
  year: number;
  broken: boolean;
  summary(): string;  // a function  that takes no parameters and returns a string
}

// this function will ONLY accept an argument that fits this object type

const print = (vehicle: Vehicle): void => console.log(`Name: ${vehicle.name})

```

If you add more than what's listed in the interface, TS will not check these

### Optional Properties

```js
function printName(obj: { first: string; last?: string }) {
  // ...
}

// Both OK
printName({ first: "Bob" });
printName({ first: "Alice", last: "Alisson" });
```

In JavaScript, if you access a property that doesnâ€™t exist, youâ€™ll get the value `undefined` rather than a runtime error. Because of this, when you *read* from an optional property, youâ€™ll have to check for `undefined` before using it.

### Object literal

```
let point: {x: number; y: number} = { x:10, y: 5 }
```

### Changing an object

```js
const a = {b: 3}
... NO: a = {c: 4} NO: a = {b:4}
YES: a.c=5;
```

Objects

1.  ```ts
    const json = '{"x": 10, "y": 20}';
    const coord = JSON.parse(json); // JSON.parse or any builtin function will return any
    // instead
    const coord: {x:number, y: number} = JSON.parse(json) // now we annotate what type JSON.parse will return
    ```

---

## JS-UI libs/typescript/2-basic types/5-object-types/dynamic-keys.md

https://newbedev.com/interface-for-dynamic-key-in-typescript

---

## JS-UI libs/typescript/2-basic types/5-object-types/object types.md

Function type expressions

There are various types:

**object types** can be represented in 3 ways.

The following describes an object that has two properties: one is a string type, the other a number.

1.  anonymous

```tsx
person: { name: string, age: number }
```

2.  interface

```
interface Person { name: string; age: number }
person: Person;
```

3.  type alias

```
type Person = { name: string; age: number };
person: Person;
```

**An object ...**

var x = {}

**... is created from a constructor (function) ..**

var x = new function() {};

**.. or a class**

var x = new class {}

---

## JS-UI libs/typescript/2-basic types/5-object-types/promise-constructor.md

**Promises**

```
const myPromise = new Promise((res, rej) => res(10));

myPromise.then(x => {console.log(x)}) //10
```

The generic type <string> refers to the return result of resolve - how?

You are calling the Promise class (constructor), which accepts any type and assigns it to the return of one of these functions.

-   What's the difference?
-   promise object - what's returned by a promise class; represents the eventual completion of value; its a proxy for a value not necessarily known. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
-   promise class - that which instantiates the object
-   promise constructor - what we call with `new` and we pass in a function that it runs: (r,r) => r(10);

```
const myPromise = new Promise<string>((resolve, reject) => {
   resolve(10)});

myPromise.then(x => {console.log(x)})
```

There are just a few differences between class constructor signatures and function signatures:

-   Constructors canâ€™t have type parameters - these belong on the outer class declaration, which weâ€™ll learn about later
-   Constructors canâ€™t have return type annotations - the class instance type is always whatâ€™s returned

src/actions/app.ts:383:9 - error TS2794: Expected 1 arguments, but got 0. Did you forget to include 'void' in your type argument to 'Promise'?

383 res();
\~\~\~\~\~

https://stackoverflow.com/questions/65354965/error-ts2794-expected-1-arguments-but-got-0-did-you-forget-to-include-void

This function will return a Promise

the type refers to the return? or the promise itself will be a number?

```js
Function test(arg: string): Promise<number> {
    return new Promise<number>((resolve, reject) => {
        if (arg === "a") {
            resolve(1);
        } else {
            reject("1");
        }
    });
}
```

begin again
